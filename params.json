{
  "name": "Morphinas",
  "tagline": "Bleeding Edge of MorphAnalyzer",
  "body": "#Morphinas\r\n###A Morphological Analyzer for Tagalog. \r\nCurrently in private.\r\nIf you need more information or access, please email laurenz@outlook.ph\r\n\r\n#I.\tMORPHOLOGICAL ANALYZER\r\n\r\nMorphological analyzers (MA) are systems that extracts the root word, affixes applied, and semantic changes on a transformed word (See & Cheng, 2006). Morphological analyzers are used in the field of natural language processing especially in the fields of information retrieval and machine translation.\r\n\r\nMorphemes are the elements of a word that are being processed by morphological analyzers. A morpheme is the smallest unit of a word that has meaning or contributes to the original meaning of the word. A morphological analyzer analyzes morphemes which may be either a root word or an affix (prefix, suffix, or infix). Formations of a root word and affixes create a transformed word. A transformed word may either be formed through inflections or through derivations. Inflections happen when affixes added to the root’s indicate tense or plurality (ex: talk-talked) while derivations happen when affixes completely change the meaning of the word (ex: read-reader) (Oiry, 2009). \r\n\r\nA morphological analyzer may be implemented through either a rule-based approach or an example-based approach. Rule-based morphological analyzers are known to be costly when being implemented as they take a lot of resource and time in order to generate the rules needed to analyze words for a certain language. Example-based morphological analyzers are capable of learning the morphological rules of any language instead of manually creating the rules through providing a sample lexicon or corpus for a specific language (See, 2006). \r\n\r\n##A.\tWordFrame Model (Wicentowski, 2002)\r\n\r\nThe WordFrame model is a noise-robust supervised multilingual morphological analyzer algorithm with a median accuracy of 97.5% that can be used on languages with prefixes, suffixes and internal vowel shifts (Wicentowski, 2004). The model learns transductions from inflected-root word pairs and patterns extracted from a large amount of noisy training data. The transductions model the prefixation, suffixation, point-of-affixation, and semi-internal vowel shifts while the patterns align inflections with roots in languages that contains vowel harmony, agglutination, and partial word reduplication (Wicentowski, 2004). \r\n\r\nWordFrame splits a transformed word into seven parts. The canonical prefix (ψp), point-of-prefixation (δp), the common substring before the vowel (γp), the internal vowel(δv), common substring after the internal vowel (γs), the point-of-suffixation (δs), and the canonical suffix (ψs). These seven parts constitute into a transformed word:\r\n\r\nWord (ψp’ → ψp, δp’→δp, γp, δv’→δv, γs, δs’→δs, ψs’→ψs)\r\n\r\n1.\tCanonical Prefix (ψp’, ψp): A common/known prefix added at the beginning of the word.\r\n2.\tPoint-of-prefixation (δp’, δp): A non-canonical prefix string change that occurs before the left-most common substring (γp).\r\n3.\tCommon Substring (left-γp, right-γs): The largest common substring occurring between the word pair and the transformed word. The leftmost common substring (γp) occurs before the internal vowel change (δv) while the rightmost common substring (γs) occurs after the internal vowel change (δv).\r\n4.\tInternal vowel change (δv’, δv): A non-empty string (δv’) which consists of vowels situated between the left and right common substrings \r\n5.\tPoint-of-suffixation (δs’, δs): A non-canonical suffix string change that occurs after the rightmost common substring (γs).\r\n6.\tCanonical Suffix (ψs’, ψs): A common/known suffix added at the after the end of the word.\r\n\r\nWhere Xy’ (with prime) denotes a transformed word segment and Xy (without prime) denotes segment from root word.\r\n\r\nThe model allows for including a predefined set of prefixes that a user can provide which can help in automatically discover the point-of-prefixation stem change δp’ -> δp.\r\n\r\n###1.\tProcess\r\n\r\nThe WordFrame model’s process in extracting the root word starts with identifying the longest common substring with at most a single vowel where the left (γp) and right (γs) common substrings are not empty if there is an internal vowel change. \r\n\r\nGiven the found common substrings hab-(δv’)-l in naghabulan:\r\nγp, (δv’→δv), γs = ‘hab’, (‘u’→’o’), ‘l’\r\n\r\nWhen the word has γp or γs as an empty string like the word sunduin where the root word is sundo, the internal vowel change (δv’) is considered as a point-of-affixation (δp’/ δs’) instead.\r\n\r\nGiven the found common substrings sund-(δv’) in sunduin:\r\nγp, (δv’→δv), γs, (δs’→ δs) = ‘sund’, (‘u’→’o’), ε, (‘in’ → ε)\r\n\r\nThe next step is to identify and remove the longest matching Canonical Affixes (ψp’ → ψp / ψs’→ψs) and applying point-of-affixation changes when needed.\r\n\r\nContinuing on the words naghabulan and sunduin:\r\nW((ψp’ → ψp), (δp’→δp), γp, (δv’→δv), γs, (δs’→δs), (ψs’→ψs)) = \r\nW( (‘nag’→ε), ε, ‘hab’, ‘o’, ‘l’, ε, ‘an’→ε)  = ‘habol’\r\n\r\nW((ψp’ → ψp), (δp’→δp), γp, (δv’→δv), γs, (δs’→δs), (ψs’→ψs)) = \r\nW( ε, ε, ’sund’, ε, (‘u’→’o’), (‘in’→ε) ) = ‘sundo’\r\n\r\n##B.\tA Tagalog Morphological Analyzer using Example-Based Approach (See, 2006)\r\n\r\nThe work of See (2006) aims to revise WordFrame specifically for the complexity of the Filipino language. The Filipino language’s morphology is much more complex when compared to English. The language includes infixation (ex: lumakad), circumfixation (where an affix made up of two separate parts surrounds and attaches to a root), partial word reduplication (ex: lalakad), and whole word reduplication on top of the common prefixation, suffixation, and internal vowel changes. Unlike the English language, a Filipino word may include more than one prefix on a single word. These issues are some of the reasons why the original WordFrame model is not enough to handle the Filipino language. The revised system consists of two phases called training phase and analysis phase. The training phase was done by supplying the system with training data which consists of word pairs (transformed word paired with the root word) and its associated morphological category (tense). A morphological learner runs through these word pairs in order to store a lexicon on a Microsoft Access Database (AccessDB or .mdb file) which contains a list of known roots and the morphological rules. The analysis phase wherein the learned morphological rules stored earlier on the training phase are applied on words from the Filipino language. Once the appropriate rules are applied on the word, the engine would then search the lexicon of possible root word candidates. \r\n\r\n###1.\tRevised Process\r\n\r\nAlthough WordFrame is was tested by Wicentowski (2002) on Tagalog verbs, it models infixations as well as partial reduplications found on the Filipino language as part of the point-of-affixation. To properly handle infixation and reduplication that cannot be handled by the original WordFrame model, WFInfix and WFRedup where added on the original WordFrame model. This revised model improves on the original model by identifying the infixes and reduplications before proceeding with the process of the original WordFrame model. The revised word segmentation of a transformed word is as follows: \r\n\r\nWord (ψp’, σp’, τi’, σs’, δp’, γp, δv’, γs, δs’, ψs’)\r\n\r\nIn the revised Filipino model, σp’ and σs’ represents the partial/whole word reduplication segments and τi’ represents the canonical infix inside the transformed word. The system would require a list of canonical/known infixes just like the list of prefixes. The first step of the revised process is to identify the longest common substring γp, (δv’→δv), γs. \r\n\r\nGiven the word pinahintay:\r\nγp, (δv’→δv), γs = ‘hintay’ \r\n\r\nThe closest string at the start of the inflection and before the common substring is then checked if it is a canonical prefix (τi) and then removed:\r\n\r\n[ψp’→ψp], (τi’→τi), [γp, (δv’→ δv), γs] = [p] + (‘in’→ε) + [a], [‘hintay’, ‘ε’, ‘ε’] \r\n\r\nAfter removing the canonical infix (τi), the longest canonical prefix (ψp’) and (ψs’) are then identified and removed:\r\n\r\n\t[ψp’→ψp], (τi), [γp, (δv’→ δv), γs] = [‘pa’→ε], (ε), [‘hintay’, ‘ε’, ‘ε’] = hintay\r\n\r\nThe resulting substring after the previous step may contain reduplication σp’, σs’. In identifying the reduplication in the word, the longest prefix with at most one internal vowel change.\r\n\r\nGiven the word hihintayin:\r\n\r\nW (ψp, (σp’→ σp), τi, (σs’→ σs), δp, γp, δv, γs, δs, (ψs’→ ψs)) = \r\nW (ε, (‘hi’→ ε), ε, (ε→ ε), ε, ‘hintay’, ε, ε, ε, (‘in’→ ε) =\r\n‘hintay’ \r\n\r\n##C.\tMorphinas\r\n\r\nMorphinas aims to improve upon on See’s (2006) work while at the same time creating an accessible application programming interface (API) for Gramatika which means its output must be useable outside the confines of the previous works. Currently, Morphinas has added minor tweaks in the algorithm but instead prioritized on creating the necessary output needed by the other modules of the system. The lexicon stored on a Microsoft Access Database has also been converted into a MySQL Database so that it can be accessed on different platforms. \r\n\r\n###1.\tCurrent Implementation\r\n\r\nAdditional set of canonical prefixes, infixes, and suffixes were added to See’s (2006) work in order to improve removing the canonical affixes using the model. Although improved slightly the results, it has proven ineffective in removing canonical affixes especially the combination of prefixes. Phenomena such as infixes inside the prefixes are one of the issues needed to be answered on Morphinas. When infixes such as ‘in’ are present between the prefix ‘pa’ and ‘nag’, it becomes ‘pinag’ or sometimes ‘pinagpa’. These combination of infixes situated between prefixes are not created random but in fact, can be stored and can be treated as one. Instead of treating ‘pinagpa’ as a combination of prefixes and infixes, it is treated as a long prefix or as a special kind of prefix.\r\n\r\nGiven the word pinaghintay:\r\n\r\nPrevious model:\r\nW (ψp, (σp’→ σp), τi, (σs’→ σs), [δp, γp, δv, γs, δs], (ψs’→ ψs)) =\r\n( ‘pa’→ε), ε, (‘in’→ε), ε, (‘nag’→ε) [ ‘hintay’, ε, ε], ε ) =\r\n‘hintay’\r\n\r\nProposed model:\r\nW (ψp, (σp’→ σp), τi, (σs’→ σs), [δp, γp, δv, γs, δs], (ψs’→ ψs)) =\r\n( ‘pinag’→ε), ε, ε, ε, [ ‘hintay’, ε, ε], ε ) =\r\n‘hintay’\r\n\r\nThis suggested improvement reduces the additional steps needed when applying rules with infixes found between prefixes and the unintended addition of new prefixes but also allows the previous model in searching for infixes found inside the root [δp, (τi→ε), γp, δv, γs, δs] (ex: ‘l’+(um→ε)+’akad’) as the previous model only allows for identification and removal of a single infix. Unlike the previous model, all affixes found are stored by the system temporarily as an object. These affixes are then trimmed down and formatted in such a way that they can be used by the other modules of Gramatika. The system iterates through all found affixes on a transformed word and generates an output with only the features (ex: pinaghintay → ~pi~nag), the breakdown (ex: pinaghintay → ~pi~nag#hintay), or just the root word (ex: pinaghintay → hintay). \r\n\r\nWith the suggested model of handling long-prefixes, additional canonical affixes, and minor tweaks in the algorithm, Morphinas has correctly processed 114 words out of 133 words in 5 sentences (85.71%) over TPOST/HPOST’s own feature and root word extractor which only correctly processed 104 out of 133 words (78.2%) from the same 5 sentences. Unlike the previous work, Morphinas treats whole word reduplication as prefixes so that partial reduplications can still be found.\r\n\r\nMorphinas was able to generate features of 15,163 words from 534 sentences in 4.73400 seconds and is expected to finish even earlier when the database has been transferred to a flat file format.\r\n\r\n###2.\tFuture Plans\r\n\r\nThe system system still has problem in extracting the features and the correct root word from transformed words that contain reduplication and more than one affixes. It has been recommended to add another step before the original WordFrame model applies its algorithm, which is similar to See’s (2006) work wherein he added his own infix and reduplication algorithm just before WordFrame searches for canonical prefix. In doing so, the WordFrame model will only need to deal with canonical affixes and internal vowel changes. There is also a need to improve point-of-affixation especially in r→d and u→a. Accomplishing these changes can improve the number of correctly extracted features and root word started by the previous works of Wicentowski (2002) and See (2006) and improve the research on Filipino morphological analyzers.\r\n\r\n\r\n#References\r\n\r\nWicentowski, R. (2004). Multilingual Noise-Robust Supervised Morphological Analysis using the WordFrame Model. Swarthmore, Pennsylvania, USA: In Proceedings of the 7th ACL Special Interest Group in Computational Phonology (SIGPHON).\r\n\r\nSee, S., & Cheng, C. (2006). The Revised Wordframe Model for the Filipino Language. Manila, NCR, Philippines: College of Computer Studies - De La Salle University.\r\n\r\nSee, S. (2006). A Tagalog Morphological Analyzer using Example-Based Approach. College of Computer Studies. Manila: De La Salle University.\r\n\r\nOiry, M. (2009). Morphology. Department of Linguistics. Amherst, MA: University of Massachusetts.\r\n\r\n\r\n\r\n<!--\r\n### Welcome to GitHub Pages.\r\nThis automatic page generator is the easiest way to create beautiful pages for all of your projects. Author your page content here [using GitHub Flavored Markdown](https://guides.github.com/features/mastering-markdown/), select a template crafted by a designer, and publish. After your page is generated, you can check out the new `gh-pages` branch locally. If you’re using GitHub Desktop, simply sync your repository and you’ll see the new branch.\r\n\r\n### Designer Templates\r\nWe’ve crafted some handsome templates for you to use. Go ahead and click 'Continue to layouts' to browse through them. You can easily go back to edit your page before publishing. After publishing your page, you can revisit the page generator and switch to another theme. Your Page content will be preserved.\r\n\r\n### Creating pages manually\r\nIf you prefer to not use the automatic generator, push a branch named `gh-pages` to your repository to create a page manually. In addition to supporting regular HTML content, GitHub Pages support Jekyll, a simple, blog aware static site generator. Jekyll makes it easy to create site-wide headers and footers without having to copy them across every page. It also offers intelligent blog support and other advanced templating features.\r\n\r\n### Authors and Contributors\r\nYou can @mention a GitHub username to generate a link to their profile. The resulting `<a>` element will link to the contributor’s GitHub Profile. For example: In 2007, Chris Wanstrath (@defunkt), PJ Hyett (@pjhyett), and Tom Preston-Werner (@mojombo) founded GitHub.\r\n\r\n### Support or Contact\r\nHaving trouble with Pages? Check out our [documentation](https://help.github.com/pages) or [contact support](https://github.com/contact) and we’ll help you sort it out.\r\n-->\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}